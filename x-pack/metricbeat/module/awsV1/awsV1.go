// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package awsV1

import (
	"context"
	"fmt"
	"reflect"

	"time"

	awssdk "github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/cloudwatch"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/aws/aws-sdk-go/service/rds"
	"github.com/aws/aws-sdk-go/service/resourcegroupstaggingapi"
	"github.com/aws/aws-sdk-go/service/sts"

	"github.com/elastic/beats/v7/metricbeat/mb"
	awscommon "github.com/elastic/beats/v7/x-pack/libbeat/common/awsV1"
	"github.com/elastic/beats/v7/x-pack/metricbeat/module/aws"
)

type describeRegionsClient interface {
	DescribeRegions(params *ec2.DescribeRegionsInput) (*ec2.DescribeRegionsOutput, error)
}

// Config defines all required and optional parameters for aws metricsets
type Config struct {
	Period     time.Duration       `config:"period" validate:"nonzero,required"`
	Regions    []string            `config:"regions"`
	Latency    time.Duration       `config:"latency"`
	AWSConfig  awscommon.ConfigAWS `config:",inline"`
	TagsFilter []aws.Tag           `config:"tags_filter"`
}

// MetricSet is the base metricset for all aws metricsets
type MetricSet struct {
	mb.BaseMetricSet
	RegionsList []string
	Endpoint    string
	Period      time.Duration
	Latency     time.Duration
	AwsConfig   *awssdk.Config
	AccountName string
	AccountID   string
	TagsFilter  []aws.Tag
}

// ModuleName is the name of this module.
const ModuleName = "awsV1"

func init() {
	if err := mb.Registry.AddModule(ModuleName, newModule); err != nil {
		panic(err)
	}
}

func newModule(base mb.BaseModule) (mb.Module, error) {
	var config Config
	if err := base.UnpackConfig(&config); err != nil {
		return nil, err
	}
	return &base, nil
}

// NewMetricSet creates a base metricset for aws metricsets
func NewMetricSet(base mb.BaseMetricSet) (*MetricSet, error) {
	var config Config
	err := base.Module().UnpackConfig(&config)
	if err != nil {
		return nil, err
	}

	awsConfig, err := awscommon.InitializeAWSConfig(config.AWSConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to get aws credentials, please check AWS credential in config: %w", err)
	}

	_, err = awsConfig.Credentials.GetWithContext(context.Background())
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve aws credentials, please check AWS credential in config: %w", err)
	}

	base.Logger().Debug("aws config endpoint = ", config.AWSConfig.Endpoint)
	metricSet := MetricSet{
		BaseMetricSet: base,
		Period:        config.Period,
		Latency:       config.Latency,
		AwsConfig:     &awsConfig,
		TagsFilter:    config.TagsFilter,
		Endpoint:      config.AWSConfig.Endpoint,
	}

	base.Logger().Debug("Metricset level config for period: ", metricSet.Period)
	base.Logger().Debug("Metricset level config for tags filter: ", metricSet.TagsFilter)
	base.Logger().Warn("extra charges on AWS API requests will be generated by this metricset")

	// If regions in config is not empty, then overwrite the awsConfig.Region
	if len(config.Regions) > 0 {
		awsConfig.Region = &config.Regions[0]
	}

	// Get IAM account id
	mySession := session.Must(session.NewSession())
	svcSts := sts.New(mySession, &awsConfig)
	outputIdentity, err := svcSts.GetCallerIdentity(&sts.GetCallerIdentityInput{})
	if err != nil {
		base.Logger().Warn("failed to get caller identity, please check permission setting: ", err)
	} else {
		metricSet.AccountID = *outputIdentity.Account
		base.Logger().Debug("AWS Credentials belong to account ID: ", metricSet.AccountID)
	}
	// Get account name/alias
	svcIam := iam.New(mySession, &awsConfig)
	metricSet.AccountName = getAccountName(svcIam, base, metricSet)

	// Construct MetricSet with a full regions list
	if config.Regions == nil {
		svcEC2 := ec2.New(mySession, &awsConfig)
		completeRegionsList, err := getRegions(svcEC2)
		if err != nil {
			return nil, err
		}

		metricSet.RegionsList = completeRegionsList
		base.Logger().Debug("Metricset level config for regions: ", metricSet.RegionsList)
		return &metricSet, nil
	}

	// Construct MetricSet with specific regions list from config
	metricSet.RegionsList = config.Regions
	base.Logger().Debug("Metricset level config for regions: ", metricSet.RegionsList)
	return &metricSet, nil
}

func getRegions(svc describeRegionsClient) ([]string, error) {
	completeRegionsList := make([]string, 0)
	input := &ec2.DescribeRegionsInput{}
	output, err := svc.DescribeRegions(input)
	if err != nil {
		err = fmt.Errorf("failed DescribeRegions: %w", err)
		return completeRegionsList, err
	}
	for _, region := range output.Regions {
		completeRegionsList = append(completeRegionsList, *region.RegionName)
	}
	return completeRegionsList, err
}

func getAccountName(svc *iam.IAM, base mb.BaseMetricSet, metricSet MetricSet) string {
	output, err := svc.ListAccountAliases(&iam.ListAccountAliasesInput{})

	accountName := metricSet.AccountID
	if err != nil {
		base.Logger().Warn("failed to list account aliases, please check permission setting: ", err)
		return accountName
	}

	// When there is no account alias, account ID will be used as cloud.account.name
	if len(output.AccountAliases) == 0 {
		accountName = metricSet.AccountID
		base.Logger().Debug("AWS Credentials belong to account ID: ", metricSet.AccountID)
		return accountName
	}

	// There can be more than one aliases for each account, for now we are only
	// collecting the first one.
	accountName = *output.AccountAliases[0]
	base.Logger().Debug("AWS Credentials belong to account name: ", metricSet.AccountName)
	return accountName
}

// FindTimestamp function checks MetricDataResults and find the timestamp to collect metrics from.
// For example, MetricDataResults might look like:
// metricDataResults =  [{
//	 Id: "sqs0",
//   Label: "testName SentMessageSize",
//   StatusCode: Complete,
//   Timestamps: [2019-03-11 17:45:00 +0000 UTC],
//   Values: [981]
// } {
//	 Id: "sqs1",
//	 Label: "testName NumberOfMessagesSent",
//	 StatusCode: Complete,
//	 Timestamps: [2019-03-11 17:45:00 +0000 UTC,2019-03-11 17:40:00 +0000 UTC],
//	 Values: [0.5,0]
// }]
// This case, we are collecting values for both metrics from timestamp 2019-03-11 17:45:00 +0000 UTC.
func FindTimestamp(getMetricDataResults []cloudwatch.MetricDataResult) time.Time {
	timestamp := time.Time{}
	for _, output := range getMetricDataResults {
		// When there are outputs with one timestamp, use this timestamp.
		if output.Timestamps != nil && len(output.Timestamps) == 1 {
			// Use the first timestamp from Timestamps field to collect the latest data.
			timestamp = *output.Timestamps[0]
			return timestamp
		}
	}

	// When there is no output with one timestamp, use the latest timestamp from timestamp list.
	if timestamp.IsZero() {
		for _, output := range getMetricDataResults {
			// When there are outputs with one timestamp, use this timestamp
			if output.Timestamps != nil && len(output.Timestamps) > 1 {
				// Example Timestamps: [2019-03-11 17:36:00 +0000 UTC,2019-03-11 17:31:00 +0000 UTC]
				timestamp = *output.Timestamps[0]
				return timestamp
			}
		}
	}

	return timestamp
}

func Paginate(paginationToken *string, svc resourcegroupstaggingapi.ResourceGroupsTaggingAPI) (*resourcegroupstaggingapi.GetResourcesOutput, error) {
	rsTypeFilter := "synthetics"
	getResourcesInput := &resourcegroupstaggingapi.GetResourcesInput{
		PaginationToken: paginationToken,
		ResourceTypeFilters: []*string{
			&rsTypeFilter,
		},
	}

	req, resp := svc.GetResourcesRequest(getResourcesInput)
	err := req.Send()

	return resp, err
}

// GetResourcesTags function queries AWS resource groupings tagging API
// to get a resource tag mapping with specific resource type filters
func GetResourcesTags(svc resourcegroupstaggingapi.ResourceGroupsTaggingAPI, resourceTypeFilters []string) (map[string][]resourcegroupstaggingapi.Tag, error) {
	if resourceTypeFilters == nil {
		return map[string][]resourcegroupstaggingapi.Tag{}, nil
	}

	resourceTagMap := make(map[string][]resourcegroupstaggingapi.Tag)
	resp, err := Paginate(nil, svc)

	for ok := true; ok; ok = (resp.PaginationToken != nil && *resp.PaginationToken != "") {
		for _, resourceTag := range resp.ResourceTagMappingList {
			shortIdentifier, err := aws.FindShortIdentifierFromARN(*resourceTag.ResourceARN)
			if err == nil {
				resourceTagMap[shortIdentifier] = DereferenceArr(resourceTag.Tags).([]resourcegroupstaggingapi.Tag)
			} else {
				err = fmt.Errorf("error occurs when processing shortIdentifier: %w", err)
				return nil, err
			}

			wholeIdentifier, err := aws.FindWholeIdentifierFromARN(*resourceTag.ResourceARN)
			if err == nil {
				resourceTagMap[wholeIdentifier] = DereferenceArr(resourceTag.Tags).([]resourcegroupstaggingapi.Tag)
			} else {
				err = fmt.Errorf("error occurs when processing longIdentifier: %w", err)
				return nil, err
			}
		}
		resp, err = Paginate(resp.PaginationToken, svc)
	}

	return resourceTagMap, err
}

// CheckTagFiltersExist compare tags filter with a set of tags to see if tags
// filter is a subset of tags
func CheckTagFiltersExist(tagsFilter []aws.Tag, tags interface{}) bool {
	var tagKeys []string
	var tagValues []string

	switch tags := tags.(type) {
	case []resourcegroupstaggingapi.Tag:
		for _, tag := range tags {
			tagKeys = append(tagKeys, *tag.Key)
			tagValues = append(tagValues, *tag.Value)
		}
	case []ec2.Tag:
		for _, tag := range tags {
			tagKeys = append(tagKeys, *tag.Key)
			tagValues = append(tagValues, *tag.Value)
		}
	case []rds.Tag:
		for _, tag := range tags {
			tagKeys = append(tagKeys, *tag.Key)
			tagValues = append(tagValues, *tag.Value)
		}
	}

	for _, tagFilter := range tagsFilter {
		if exists, idx := aws.StringInSlice(tagFilter.Key, tagKeys); exists {
			valueExists, _ := aws.StringInSlice(tagValues[idx], tagFilter.Value)
			if !valueExists {
				return false
			}
		} else {
			return false
		}
	}
	return true
}

func PointersOf(v interface{}) interface{} {
	in := reflect.ValueOf(v)
	out := reflect.MakeSlice(reflect.SliceOf(reflect.PtrTo(in.Type().Elem())), in.Len(), in.Len())
	for i := 0; i < in.Len(); i++ {
		out.Index(i).Set(in.Index(i).Addr())
	}
	return out.Interface()
}

func DereferenceArr(v interface{}) interface{} {
	in := reflect.ValueOf(v)
	out := reflect.MakeSlice(reflect.SliceOf(reflect.TypeOf(v).Elem().Elem()), in.Len(), in.Len())
	for i := 0; i < in.Len(); i++ {
		out.Index(i).Set(in.Index(i).Elem())
	}
	return out.Interface()
}
